---
title: Reviewer Guidelines
date: 03-14-2015
layout: default
---

# Our Review Philosophy
Reviewing for the _Programming Historian_ is a great way to learn new skills and contribute to the Digital Humanities community at the same time. We go out of our way to make sure our reviewers get ample credit for their work.

## Collaborative, Not Judgmental
Our peer review process is a bit different from what might be considered the "traditional" peer review process. We do not solicit reviews to judge whether a tutorial is "good enough" to be published. Rather, we consider it an integral component of a collaborative, productive, and sustainable effort for scholars to create useful technical resources for each other.

## Constructive Criticism for Colleagues
We ask that reviewers comment on tutorials as they would on a paper or similar for a colleague--to provide fair and constructive criticism (and of course praise) that will improve the tutorial for a wide range of readers. We don't send anything out for review that isn't within a reasonable distance of publishable quality. A few extra perspectives and suggestions (beyond those of the editor) greatly improve lessons and make them of great (and unique) value to the community.

## Transparency
We highly value transparency in our lesson production and review process. Our review process happens at Github, where our lessons are hosted. Namely, we use Github's commenting and issue tracking capabilities to keep track of suggestions and how they are handled and discussed by the authors and reviewers. This helps avoid important conversations becoming lost in archived email threads. 

Therefore, your work as a reviewer--and your identity--will be fully visible to the author. Comments should engage with the author and lesson directly, rather than the review editor. If you as a reviewer would like to share some comments privately with the reviewing editor, you are welcome to email those separately, but we aim for as much transparency as possible. 

Unless you instruct us otherwise, your name will be indicated as a reviewer on the lesson's page at _Programming Historian_ when it is officially published; you'll also be listed on our contributors page. These are, of course, insufficient tokens of appreciation, but we want to emphasize that _Programming Historian_ is the work of volunteers and give credit where credit is due.

## What To Comment On
The informal style of _Programming Historian_ lessons can make the lessons appear deceptively simple to write. In fact, writing a good lesson is every bit as demanding, if not more so, than any other kind of scholarly writing. Below are a few common questions to keep in mind as you review a lesson. Some will be more relevant than others, depending on the topic, intended audience, and the difficulty of the tutorial. Needless to say, this is neither a restrictive or comprehensive list; we do not ask that reviewers respond to each and every question. But it should provide a set of concerns that will helpfully guide reviews.

### Audience
If you haven't dabbled at the _Programming Historian_ already, you'll see that there is no standard audience across all the lessons. Some are for complete beginners, others are for those considerably more comfortable with technical concepts and methods, and yet others are directed toward experienced digital historians looking to solve difficult technical challenges. We welcome such variety!

While we like each of our lessons to take the unique voice of its author, we also want each individual lesson to remain clear and consistent in its tone. More specifically, we want the technical explanations (and difficulty) to remain as constant as possible. As a reviewer, it is quite useful to note any sections of a tutorial directed at more technically advanced users that seem to over-explain relatively simple concepts; the converse is true, too: we want to avoid sections of tutorials aimed at beginners that don't adequately explain fundamental concepts central to the tutorial.

- Does the author address a consistent model reader throughout the lesson? 
- Are some concepts or steps over-explained while other are under-explained?
- Does the audience seem to match at least vaguely with other _Programming Historian_ lessons? How is it new?

### Getting Ready
- What software / programming languages are required?
- What prerequisite skills are needed?
- What familiarity or experience is needed?
- What data is needed? Is it readily available?

### Skimmability
- Are there clearly defined learning objectives or set of skills near the top of the lesson?
- Are there useful secondary skills to be gained / practiced from the lesson?
- Do screenshots and other diagrams illustrate crucial points of the lesson?
- Do sections and section headings provide clear signage to the reader?

### Payoff
- Does the tutorial suggest why the explained tools or techniques are useful in a general way?
- Does the tutorial suggest how a reader could apply the concepts (if not concrete steps) of the lesson to their own work?

### Workflow
- Should a long lesson be divided into smaller lessons?
- Are there logical stopping points throughout the lesson?
- If data is required, it is available to download at various points throughout the lesson (or different versions of it as the tutorial may require)?

### Integrating with the _Programming Historian_
- Does the lesson build upon an existing lesson and explain how? 
- Does the lesson tie into existing lessons and have appropriate links?

